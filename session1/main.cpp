#include <iostream>
using namespace std;

//在cpp中，结构体可以通用 ，结构体是一种特殊的类，是用struct定义的类 。不同之处在于：结构体默认所有成员是公有的，可以被访问的，类默认是私有的，不能被访问，要设置为public 
//struct Point
class Point
{
//public表示所有 数据成员和成员函数可以在外面被访问
//private  表示数据成员和成员函数不能被访问 
// protected是在子类和父类之间的访问控制 
public:

	int x;
	int y;
	/* 
	//初始化 
	void init()
	{
		x = 1;
		y = 1;
	}
	*/
	
	/*
	构造函数 取类名，唯一性，没有返回值 ，对象自动调用 
	构造函数最重要的作用是创建对象本身；cpp规定，每个类必须有一个构造函数，没有构造函数就不能创建任何对象 ；
	cpp又规定，如果一个类没有提供任何的构造函数，则默认提供一个，这个默认的构造函数不带参数，只负责创建对象，不做任何的初始化工作
	只要一个类定义了构造函数，不管这个构造函数是否带参数，cpp就不再提供默认的构造函数了。也就是说，如果为一个类定义了一个带参数的构造函数，还想要无参数的构造函数，必须自己定义 
	*/ 
	Point ()
	{
		x = 0;
		y = 0;
	 } 
	 /*
	 当存在一个无参的构造函数后，还有一个有参数的构造函数，这叫重载 ，当然重载 也可以出现在普通函数中
	 重载构成的条件：函数的参数类型，参数个数不同，才能构成函数的重载
	 
	 */
	 Point(int a,int b)
	 {
	 	x = a;
	 	y = b;
	 }
	 /*
	  析构函数是构造函数的取反  命名:‘~’+类名 。用于对象周期结束内存的回收 和对象的释放 
	  析构函数不允许带参数 和返回值 
	 */
	 ~Point() 
	 {
	  }
	void output()
	{
		cout<<x<<endl<<y<<endl;
	}
	void output(int a,int b) 
	{
		this->x = a;//这是一个指针 ；this指针是一个隐含的指针，他是指向对象本身，代表了对象的的地址，而不是类的地址 
		this->y = b;
		//cout<<x<<endl<<y<<endl;
	}
};

int main()
{
	Point pt(3,3);
	pt.output(5,5);
	//pt.init();
	//pt.x = 5;
	//pt.y = 5;
	//cout<<pt.x<<endl<<pt.y<<endl;
	pt.output();
}
